import threading
import time
from collections import deque
from queue import Queue, Full, Empty

# Config
CANDLE_CACHE_SIZE = 1000
FETCH_INTERVAL = 0.5  # detik
PROCESS_TIMEOUT = 2.0
EXECUTE_TIMEOUT = 5.0
QUEUE_MAXSIZE = 200

# Shared
stop_event = threading.Event()
candle_cache = deque(maxlen=CANDLE_CACHE_SIZE)
fetch_queue = Queue(maxsize=QUEUE_MAXSIZE)
exec_queue = Queue(maxsize=QUEUE_MAXSIZE)

# Helper safe MT5 call (synchronous wrapper with timeout & retries)
def safe_mt5_call(func, *args, retries=3, timeout=2.0, backoff=0.5):
    for i in range(retries):
        start = time.time()
        try:
            res = func(*args)
        except Exception as e:
            res = None
        elapsed = time.time() - start
        if res is not None:
            return res
        if elapsed > timeout:
            # treat as failure, sleep exponential backoff
            time.sleep(backoff * (i + 1))
    return None

# Fetcher
def fetcher_loop(mt5_interface):
    while not stop_event.is_set():
        data = safe_mt5_call(mt5_interface.copy_rates_from_pos, ...)
        if data:
            candle_cache.extend(data)
            try:
                fetch_queue.put_nowait(data)
            except Full:
                # drop oldest or log
                pass
        # short sleep to avoid busy loop
        time.sleep(FETCH_INTERVAL)

# Processor worker
def processor_loop():
    while not stop_event.is_set():
        try:
            data = fetch_queue.get(timeout=1)
        except Empty:
            continue
        # run indicator calculations with timeout/guards
        # push signal to exec_queue
        fetch_queue.task_done()

# Executor
def executor_loop(mt5_interface):
    while not stop_event.is_set():
        try:
            order = exec_queue.get(timeout=1)
        except Empty:
            continue
        res = safe_mt5_call(mt5_interface.order_send, order, retries=3, timeout=EXECUTE_TIMEOUT)
        exec_queue.task_done()

# Main controller to start threads
def start_all(mt5_interface):
    threads = []
    t_fetch = threading.Thread(target=fetcher_loop, args=(mt5_interface,), daemon=True)
    threads.append(t_fetch)
    for _ in range(2):
        t_proc = threading.Thread(target=processor_loop, daemon=True)
        threads.append(t_proc)
    t_exec = threading.Thread(target=executor_loop, args=(mt5_interface,), daemon=True)
    threads.append(t_exec)

    for t in threads:
        t.start()

    # monitor loop
    try:
        while not stop_event.is_set():
            # health checks, monitoring
            time.sleep(5)
    except KeyboardInterrupt:
        stop_event.set()
    finally:
        # wait gracefully with timeout
        for t in threads:
            t.join(timeout=2)